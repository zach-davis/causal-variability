
#bayesian mutation sampler
#based on model Davis & Rehder (2020)
#added bayesian version based on paper The Bayesian sampler (Zhu et al., 2020)

#######################################################
# packages
#######################################################
library(plyr)
library(dplyr)



# newest changes:
# making genchainsMS and genchainsMSpoislen also output all input parameters
# make genjoint take as input and also output all input parameters
# make genrespdistr take as input and also output all input parameters



#######################################################
# Input used in experiment: Joint / DAGS / network parametrizations / ground truth causal networks given to participants
#######################################################

# Common cause/Chain structure: samples1.xlsx, in Rottman 2016 exp 1a commoncause (x1<-y->x2) and chain (x1->y->x2), n=32
dagf1 <- data.frame(X1=c(1,1,1,1,0,0,0,0),
                    Y=c(1,1,0,0,1,1,0,0),
                    X2=c(1,0,1,0,1,0,1,0),
                    p=c(9,3,1,3,3,1,3,9))
rownames(dagf1)<- c("111", "110", "101", "100", "011", "010", "001", "000")
# Common effect structure: samples2.xlsx, in Rottman 2016 exp 1a  commoneffect (x1->y<-x2), n=32
dagf2 <- data.frame(X1=c(1,1,1,1,0,0,0,0),
                    Y=c(1,1,0,0,1,1,0,0),
                    X2=c(1,0,1,0,1,0,1,0), 
                    p=c(6,4,2,4,4,0,4,8))
rownames(dagf2)<- c("111", "110", "101", "100", "011", "010", "001", "000")



#----------------------------------------------------------
# The Mutation Sampler
#----------------------------------------------------------

# required adjacency matrix, defines what 'states' (e.g. 101) are adjacent to others (e.g. 001)
# rows indicates current state, columns indicate which states are adjacent, 1 and 8 are the prototypical states (111 and 000 respectively)
# this is the same, just a different format, as output of neigbors.of.joint() fnc when input joint is according to IK convention 111 to 000
adjmat <- as.data.frame(matrix(0, 8, 8))
adjmat[1,] <- c(0,1,1,0,1,0,0,0)
adjmat[2,] <- c(1,0,0,1,0,1,0,0)
adjmat[3,] <- c(1,0,0,1,0,0,1,0)
adjmat[4,] <- c(0,1,1,0,0,0,0,1)
adjmat[5,] <- c(1,0,0,0,0,1,1,0)
adjmat[6,] <- c(0,1,0,0,1,0,0,1)
adjmat[7,] <- c(0,0,1,0,1,0,0,1)
adjmat[8,] <- c(0,0,0,1,0,1,1,0)


## Mutation sampler
MutationSampler <- function(len, startstate, dag){
  # creates chain of samples based on Mutation sampling
  # inputs: len = length of chain, startstate = first sample, where 1 and 8 are prototypical states, dag = Df with joint, needs vars: state, x1,y,x2, and p: frequency(of samples)/joint probabiblities
  # Requires adjmat to be defined
  
  dag$jointprob <- dag$p/sum(dag$p) #so that either frequencies or probabilities can be used
  
  x = rep(0,len)
  x[1] = startstate
  for(i in 2:len){
    currentstate = x[i-1]
    proposedstate = which(adjmat[currentstate,] %in% 1)[sample(1:3,1)] # equal probability of all reachable states (1 mutated variable)
    A = dag$jointprob[proposedstate]/dag$jointprob[currentstate] #trans prob A(q'|q)  = min(1 , joint(q')/joint(q))
    if(runif(1)<A){
      x[i] = proposedstate       # accept move with probabily min(1,A)
    } else {
      x[i] = currentstate        # otherwise "reject" move, and stay where we are
    }
  }
  samples <- x 
  return(samples)
}

#----------------------------------------------------------
# Functions to manipulate generated chains
#----------------------------------------------------------

# Cut a dataframe with chains of equal length function to obtain chains with lenths sampled from a poisson distribution
cutchainspois <- function(chains, meanlen, nchains){
  # inputs: df with generated chains (each column a chain), mean length of chains, number of chains
  # arg chains is set of chains generated with MS 
  
  poislengths <- (rpois(nchains, meanlen-2))+2 #lengths based on poisson distr with minimum = 2
  cutchains <- matrix(nrow=max(poislengths), ncol=nchains)
  
  #now with loop, possibly vectorize later
  for (i in 1:nchains){
    cutchains[1:poislengths[i], i]<-chains[1:poislengths[i], i]
  }
  return(cutchains)
}

# function togo from statefreq format to dag1 format 
# from frequency of state number(1:8) (columns: statenr, freq) to variable vector long format (columns: X1,Y,X2) 
states2varsamps <- function(statefreq, dag, nchains){
  #statefreq as generated by runchainMS, ie matrix with rows indexing chains, and columns indexing states, each entry indexes how often that state occursin within that chain
  #dag = DF with dag parametrization / structure to use, needs vars: state, x1,y,x2, and frequency
  #only uses dag to see what vars each statenr refers to, doesnt use the actual frequency and stuff.
  #x <- array(0, c(len, 3, nchains)) #do list of dataframes instead!?!?!
  #x <- list() #list of data frames, each dataframe will have var samples of a chain
  
  x <- lapply(1:nchains, function(i) {
    matrix(unlist(sapply(1:8, function(ii) {
      rep(dag[ii,2:4],statefreq[i,ii])}, simplify=F)),ncol=3, byrow=T)
  })
  return(x)
}

# function togo from statefreq format to dag1f format 
# from prob of state number (columns: statenr, prob) to variable vector (columns: X1,Y,X2, prob) wide prob format
states2varsampsjoint <- function(statejoint, nchains){
  #statejoint as generated by runchainMS
  #dag = DF with dag parametrization / structure to use, needs vars: state, x1,y,x2, and frequency, only uses this to see what vars each statenr refers to

  statejoint <- as.matrix(statejoint) #ZD MS outputs statejoint as DF (compared to matrix from IK MS), this fnc requires matrix somehow.
  
  jointsetup <- data.frame(X1=c(1,1,1,1,0,0,0,0),
                          Y=c(1,1,0,0,1,1,0,0),
                          X2=c(1,0,1,0,1,0,1,0))
  rownames(jointsetup)<- c("111", "110", "101", "100", "011", "010", "001", "000") #maybe softcode this jointsetup later, depending on pipeline
  
  x <- lapply(1:nchains, function(i) {
    cbind(jointsetup,p=statejoint[i,])})
  
  return(x)
}

#----------------------------------------------------------
# Functions to generate multiple chains with mutation sampler.
#----------------------------------------------------------

genchainsMS <- function(len, nchains, bias=0.5, joint){
  # len = chain length
  # nchains = number of chains
  # bias = prob of starting at state 1
  # joint = joint DF, needs vars: state, x1,y,x2, and  p: joint probability/frequency of samples
  statefreq <- matrix(0,nchains,8)
  chainjoint <- matrix(0,nchains,8)
  samples <- matrix (0, len, nchains)
  
  normresp <- joint$normresps
  ms <- joint$ms
  bs <- joint$bs
  joint <- joint$joint
  
  for (i in 1:nchains) { #create each chain and save them
    startstate <- sample(c(1,8), 1, prob=c(bias, 1-bias))
    samples[,i] <- MutationSampler(len, startstate, joint) # all samples all chains
  }
 
  res <- list(samples=samples, meanChainlen=len, normjoint=joint, nChains=nchains, bias=bias, normresps=normresp, ms=ms, bs=bs,
              model="IK BayesianMS")
  
  
  return(res)
}


genchainsMSclean <- function(len, nchains, bias=0.5, ms, bs){
  # same as above, but without constructing and piping through additional information, just outputs the chains.
  # len = chain length
  # nchains = number of chains
  # bias = prob of starting at state 1
  # ms = causal strengths, bs=baserates
  joint <- joint.cgm.generic2(ms, bs)
  samples <- matrix (0, len, nchains)
  
  for (i in 1:nchains) { #create each chain and save them
    startstate <- sample(c(1,8), 1, prob=c(bias, 1-bias))
    samples[,i] <- MutationSampler(len, startstate, joint) # all samples all chains
  }
  return(samples)
}



# this function does same as above, but draws chain length each time from Poisson distribution according to Davis & Rehder 2020
genchainsMSpoislen <- function(meanlen, nchains, bias=0.5, joint){
  # meanlen = mean chain length, draw from poisson meanlen-2, and then plus 2
  # nchains = number of chains
  # bias = prob of starting at state 1
  # joint = joint DF, needs vars: state, x1,y,x2, and  p: joint probability/frequency of samples
  statefreq <- matrix(0,nchains,8)
  chainjoint <- matrix(0,nchains,8)
  chainlens <- rpois(nchains, meanlen-2)+2
  samples <- matrix (NaN, max(chainlens), nchains)
  
  normresp <- joint$normresps
  ms <- joint$ms
  bs <- joint$bs
  joint <- joint$joint
  
  for (i in 1:nchains) { #create each chain and calculate some stuff for each.
    startstate <- sample(c(1,8), 1, prob=c(bias, 1-bias))
    samples[1:chainlens[i],i] <- MutationSampler(chainlens[i], startstate, joint) # all samples all chains
  }
  res <- list(samples=samples, meanChainlen=meanlen, normjoint=joint, nChains=nchains, bias=bias, normresps=normresp, ms=ms, bs=bs,
              model="IK BayesianMS poisson chainlength")
  return(res)
}



#----------------------------------------------------------
# Functions to generate predicted response distributions based on chains
#----------------------------------------------------------

# Function to compute mean joint distribution, joint distribution, and chain lengths, from chains
genjoint <- function(res){ 
  # input is matrix/DF with each column being a chain, ie output from genchainsMS or genchainsMSpoislen, with 1-8 referring to states 111-000
  # outputt is list with mean joint distr, joint distr per chain, and vector chainlengths
  nchains <- ncol(res$samples)
  chainlens <- apply(res$samples, 2, function(x){length(x[!is.na(x)])}) #vector of chainlengths, doesnt count NAs, so works with varying chainlengths
  statefreq <- t(apply(res$samples, 2, function(X){table(factor(X, levels=1:8))}))
  chainjoint <- prop.table(statefreq,1)
  meanjointdistr <- apply(chainjoint, 2, mean)
  meanjointdistr <- data.frame(state = as.factor(seq(1:8)), 
                               X1=c(1,1,1,1,0,0,0,0),
                               Y=c(1,1,0,0,1,1,0,0),
                               X2=c(1,0,1,0,1,0,1,0), 
                               p=meanjointdistr)
  rownames(meanjointdistr)<- c("111", "110", "101", "100", "011", "010", "001", "000")
  res <- list(meanjoint=meanjointdistr, chainjoints=chainjoint, 
              chainlens=chainlens, meanChainlen=res$meanChainlen, normjoint=res$normjoint, nChains=res$nChains, bias=res$bias, 
              normresps=res$normresps, ms=res$ms, bs=res$bs, model=res$model)
  return(res)
}


# Function to generate DF with response distributions for each inference from chainjoint
genrespdistr <- function(res, betavar=0){
  # res should be output from genjoint, see above
  # betavar is prior beta(betavar,betavar) used for each inference
  # Output: 
  nchains <- length(res$chainlens)
  chainjoint <- res$chainjoints
  
  varjoint <- states2varsampsjoint(chainjoint, nchains) #reconstruct the causal variables from the states wide format
  chainMSprobs <- condprobMSBay2(betavar, nchains, res$chainlens, varjoint)# all possible prob inferences with prior Bayesian
  chainMSprobs <- guessMS(chainMSprobs, nchains) #fill in NAs with 0.5
  respdistr <- preddistrBay(nchains, chainMSprobs) #DF with all inferences from each chain based on prior and relative frequency
  
  res <- list(respdistr=respdistr, meanjoint=res$meanjoint, chainjoints=res$chainjoints, 
              chainlens=res$chainlens, meanChainlen=res$meanChainlen, betavar=betavar, 
              normjoint=res$normjoint, normresps=res$normresps, ms=res$ms, bs=res$bs,nChains=res$nChains, bias=res$bias, model=res$model, 
              bs_conc=res$bs_conc, ms_conc=res$ms_conc, nSamps=res$nSamps)
  
  return(res)
}

# clean version of genjoint without constructing an piping through unnecessary stuff

genjointclean <- function(samples){ 
  # input is matrix/DF with each column being a chain, ie output from genchainsMSclean, with 1-8 referring to states 111-000
  # outputt is list with mean joint distr, joint distr per chain, and vector chainlengths
  nchains <- ncol(samples)
  chainlens <- apply(samples, 2, function(x){length(x[!is.na(x)])}) #vector of chainlengths, doesnt count NAs, so works with varying chainlengths
  statefreq <- t(apply(samples, 2, function(X){table(factor(X, levels=1:8))}))
  chainjoint <- prop.table(statefreq,1)

  res <- list(chainjoint=chainjoint, chainlens=chainlens)  
  return(res)
}

# clean version of genrespdistr without constructing an piping through unnecessary stuff
BMSrespdistr <- function(res, betavar=0){
  # chainjoint should be output from genjointclean, see above
  # betavar is prior beta(betavar,betavar) used for each inference
  # Output: 
  nchains <- dim(res$chainjoint)[1]
  
  varjoint <- states2varsampsjoint(res$chainjoint, nchains) #reconstruct the causal variables from the states wide format
  chainMSprobs <- condprobMSBay2(betavar, nchains, res$chainlens, varjoint)# all possible prob inferences with prior Bayesian
  chainMSprobs <- guessMS(chainMSprobs, nchains) #fill in NAs with 0.5
  respdistr <- preddistrBay(nchains, chainMSprobs) #DF with all inferences from each chain based on prior and relative frequency
  
  return(respdistr)
}

# function to go straight from chains to predicted response distributions
chainstoresps.BMS <- function(chains, meanlen, betavar) {
  # function to go straight from chains to predicted response distributions
  chains <- cutchainspois(chains, meanlen, nchains=dim(chains)[2])
  chainjoints <- genjointclean(chains)
  respdistr <- BMSrespdistr(chainjoints, betavar=betavar)
  return(respdistr)
}

