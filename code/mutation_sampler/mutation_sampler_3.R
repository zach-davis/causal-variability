#mutation sampler
#based on paper Davis & Rehder (2020)

## packages
library(plyr)
library(ggplot2)

## preliminaries
#DAGS / network parametrizations.
# samples1.xlsx, in Rottman 2016 exp 1a commoncause (x1<-y->x2) and chain (x1->y->x2), n=32
X1<- c(rep(1,9),rep(1,3),rep(1,1),rep(1,3),rep(0,3),rep(0,1),rep(0,3),rep(0,9))
Y <- c(rep(1,9),rep(1,3),rep(0,1),rep(0,3),rep(1,3),rep(1,1),rep(0,3),rep(0,9))
X2<- c(rep(1,9),rep(0,3),rep(1,1),rep(0,3),rep(1,3),rep(0,1),rep(1,3),rep(0,9))
dag1<-data.frame(X1,Y,X2)
dagf1 <- data.frame(state=seq(1,8), 
                    X1=c(1,1,1,1,0,0,0,0),
                    Y=c(1,1,0,0,1,1,0,0),
                    X2=c(1,0,1,0,1,0,1,0),
                    freq=c(9,3,1,3,3,1,3,9))
#  samples2.xlsx, in Rottman 2016 exp 1a  commoneffect (x1->y<-x2), n=32
X1<- c(rep(1,6),rep(1,4),rep(1,2),rep(1,4),rep(0,4),rep(0,0),rep(0,4),rep(0,8))
Y <- c(rep(1,6),rep(1,4),rep(0,2),rep(0,4),rep(1,4),rep(1,0),rep(0,4),rep(0,8))
X2<- c(rep(1,6),rep(0,4),rep(1,2),rep(0,4),rep(1,4),rep(0,0),rep(1,4),rep(0,8))
dag2<-data.frame(X1,Y,X2)
dagf2 <- data.frame(state=seq(1,8), 
                    X1=c(1,1,1,1,0,0,0,0),
                    Y=c(1,1,0,0,1,1,0,0),
                    X2=c(1,0,1,0,1,0,1,0), 
                    freq=c(6,4,2,4,4,0,4,8))

# in waldmann & Rehder 2017 , exp 2 common cause,n = 33 Ei=Xi, C=Y
dagf4 <- data.frame(state=seq(1,8), 
                      X1=c(1,1,1,1,0,0,0,0),
                       Y=c(1,1,0,0,1,1,0,0),
                      X2=c(1,0,1,0,1,0,1,0), 
                    freq=c(9,3,1,3,3,1,3,10)) 


# adjacency matrix (row indicates current state, columns indicate which states are adjacent)
adjmat <- as.data.frame(matrix(0, 8, 8))
adjmat[1,] <- c(0,1,1,0,1,0,0,0)
adjmat[2,] <- c(1,0,0,1,0,1,0,0)
adjmat[3,] <- c(1,0,0,1,0,0,1,0)
adjmat[4,] <- c(0,1,1,0,0,0,0,1)
adjmat[5,] <- c(1,0,0,0,0,1,1,0)
adjmat[6,] <- c(0,1,0,0,1,0,0,1)
adjmat[7,] <- c(0,0,1,0,1,0,0,1)
adjmat[8,] <- c(0,0,0,1,0,1,1,0)


## mutation sampler

MutationSampler <- function(len, startstate, dag){
  # creates chain of samples based on Mutation sampler
  # len = length of chain
  # startstate = first sample (value 1-8), where 1 and 8 are prototypical states
  # dag = DF with dag parametrization / structure to use, needs vars: state, x1,y,x2, and frequency
  # ALSO NEEDS ADJACENCY MATRIX TO BE DEFINED
  dag$jointprob <- dag$freq/sum(dag$freq)
  
  x = rep(0,len)
  x[1] = startstate
  for(i in 2:len){
    currentstate = x[i-1]
    proposedstate = which(adjmat[currentstate,] %in% 1)[sample(1:3,1)] #equal probability of all reachable states (1 mutated variable)
    A = dag$jointprob[proposedstate]/dag$jointprob[currentstate] #trans prob A(q'|q)  = min(1 , joint(q')/joint(q))
    if(runif(1)<A){
      x[i] = proposedstate       # accept move with probabily min(1,A)
    } else {
      x[i] = currentstate        # otherwise "reject" move, and stay where we are
    }
  }
  samples <- x 
  return(samples)
}

# function togo from statefreq format to dag1 format 
# from frequency of state number (1:8) to variable vector (X1,Y,X2) long format
states2varsamps <- function(statefreq, dag){
  #statefreq as generated by runchainMS
  #dag = DF with dag parametrization / structure to use, needs vars: state, x1,y,x2, and frequency
  nchains <- nrow(statefreq) #number of chains
  #x <- array(0, c(len, 3, nchains)) #do list of dataframes instead!?!?!
  x <- list() #list of data frames, each dataframe will have var samples of a chain
  for (i in 1:nchains){ #loop through each chain
    samplenr <- 1
    len <- sum(statefreq[i,]) #length of chain
    z <- data.frame(X1 = rep(NA, len), Y = rep(NA, len), X2 = rep(NA, len)) #df to fill for each chain
    for (ii in 1:8){ #loop through freq of each state in each chain
      if (statefreq[i,ii]>0){
        for(iii in 1:statefreq[i,ii]){ #loop through the freq of each state, add X1YX2
          z[samplenr,1:3] <- dag[ii,2:4]
          samplenr <- samplenr+1
        }
      }
    }
    x[[i]] <-z
  }
  return(x)
}

# function togo from statefreq format to dag1f format 
# from prob of state number (1:8) to variable vector (X1,Y,X2, prob) wide prob format
states2varsampsjoint <- function(statejoint, dag){
  #statejoint as generated by runchainMS
  #dag = DF with dag parametrization / structure to use, needs vars: state, x1,y,x2, and frequency
  nchains <- nrow(statejoint) #number of chains
  len <- sum(statejoint[1,]) #length of chains
  #x <- array(0, c(len, 3, nchains)) #do list of dataframes instead!?!?!
  x <- list() #list of data frames, each dataframe will have var samples of a chain
  for (i in 1:nchains){ #loop through each chain
    samplenr <- 1
    z <- data.frame(X1 = rep(NA, 8), Y = rep(NA, 8), X2 = rep(NA, 8), probs = rep(NA, 8)) #df to fill for each chain
    for (ii in 1:8){ #loop through freq of each state in each chain
      z[,1:3] <- dag[,2:4]
      z[,4] <- statejoint[i,]
    }
    x[[i]] <-z
  }
  return(x)
}



## calculate averages of certain sample length, ie get mean joint distributions of certain sample length.
## D&R2020 mention that one can also calculate these analytically!!!!! See top paragraph page 8

runchainsMS <- function(len, nchains, bias, dag, betavar){
  # len = chain length
  # nchains = number of chains
  # bias = prob of starting at state 1
  # dag = DF with dag parametrization / structure to use, needs vars: state, x1,y,x2, and frequency (so format dagf1 above)
  # ALSO NEEDS ADJACENCY MATRIX TO BE DEFINED
  statefreq <- matrix(0,nchains,8)
  chainjoint <- matrix(0,nchains,8)
  samples <- matrix (0, len, nchains)
  for (i in 1:nchains) { #create each chain and calculate some stuff for each.
    startstate <- sample(c(1,8), 1, prob=c(bias, 1-bias))
    samples[,i] <- MutationSampler(len, startstate, dag) # all samples all chains
    state <- factor(samples[,i], levels = as.factor(seq(1:8))) # visited states of current chain, add factor levels so that count will inlude states with 0 values
    statefreq[i,] <- table(state) # frequency of each state per chain
    chainjoint[i,] <- statefreq[i,]/len # joint distr of states per chain
  }
  meanjointdistr <- apply(chainjoint, 2, mean)
  meanjointdistr <- data.frame(state = as.factor(seq(1:8)), prob=meanjointdistr)
  varsamples <- states2varsamps(statefreq, dag) #reconstruct the causal variables from the states long format
  varjoint <- states2varsampsjoint(chainjoint, dag) #reconstruct the causal variables from the states wide format
  res <- list(dag=dag, len=len, nchains=nchains, bias=bias, betavar=betavar,
              statesamples=samples, varsamples=varsamples, varjoint=varjoint,
              statefreq=statefreq, statejoint=chainjoint, meanjointdistr=meanjointdistr)
  res$chainprobs <- condprobMS(res) #all possible probs for each chain, NaNs if state not visited
  res$chainMSprobs <- guessMS(res$chainprobs) # all possible probs for each chains, with .5 if relevant states are not visited.
  res$respdistr <- preddistr(res) #DF with all inferences from each chain based on relative frequency
  res$chainMSBayprobs <- condprobMSBay(res) #bayesian inferred probs
  res$respdistrBay <- preddistrBay(res)
  return(res)
}

#this function does same as above, but draws chain length each time for Poisson distribution with mean L' = L-2, and then adds two, so mean nr of samples is L
runchainsMSpoislen <- function(meanlen, nchains, bias, dag, betavar){
  # meanlen = mean chain length, draw from poisson meanlen-2, and then plus 2
  # nchains = number of chains
  # bias = prob of starting at state 1
  # dag = DF with dag parametrization / structure to use, needs vars: state, x1,y,x2, and frequency (so format dagf1 above)
  # ALSO NEEDS ADJACENCY MATRIX TO BE DEFINED
  statefreq <- matrix(0,nchains,8)
  chainjoint <- matrix(0,nchains,8)
  chainlens <- rpois(nchains, meanlen-2)+2
  samples <- matrix (NaN, max(chainlens), nchains)
  for (i in 1:nchains) { #create each chain and calculate some stuff for each.
    startstate <- sample(c(1,8), 1, prob=c(bias, 1-bias))
    samples[1:chainlens[i],i] <- MutationSampler(chainlens[i], startstate, dag) # all samples all chains
    state <- factor(samples[,i], levels = as.factor(seq(1:8))) # visited states of current chain, add factor levels so that count will inlude states with 0 values
    statefreq[i,] <- table(state) # frequency of each state per chain
    chainjoint[i,] <- statefreq[i,]/chainlens[i] # joint distr of states per chain
  }
  meanjointdistr <- apply(chainjoint, 2, mean)
  meanjointdistr <- data.frame(state = as.factor(seq(1:8)), prob=meanjointdistr)
  varsamples <- states2varsamps(statefreq, dag) #reconstruct the causal variables from the states long format
  varjoint <- states2varsampsjoint(chainjoint, dag) #reconstruct the causal variables from the states wide format
  res <- list(dag=dag, meanlen=meanlen, nchains=nchains, bias=bias, betavar=betavar,
              statesamples=samples, varsamples=varsamples, varjoint=varjoint,
              statefreq=statefreq, statejoint=chainjoint, meanjointdistr=meanjointdistr, chainlens=chainlens)
  res$chainprobs <- condprobMS(res) #all possible probs for each chain, NaNs if state not visited
  res$chainMSprobs <- guessMS(res$chainprobs) # all possible probs for each chains, with .5 if relevant states are not visited.
  res$respdistr <- preddistr(res) #DF with all inferences from each chain based on relative frequency
  res$chainMSBayprobs <- condprobMSBay(res) #bayesian inferred probs
  res$respdistrBay <- preddistrBay(res)
  return(res)
}


#######################################################
# Calculate probabilities based on relative frequency.
#######################################################

condprob <- function (x, event = NULL, given = NULL, ...) {
  # calculates conditional or marginal probability based on relative frequency of samples
  # this is different function than  in condprop script, this is based on prob:::Prob.default
  # X is dataframe with column names as variables X1, Y, X2, and probs
  # event and given need to evaluate to logical expreesions (e.g. X1==1 or (X1==1&X2==0))
  # provide conditional probability. returns NaN if given/conditioning state is never observed 
  if (missing(event)) {
    r <- TRUE
  }
  else {
    e <- substitute(event)
    r <- eval(e, x, parent.frame())
    r <- r & !is.na(r)
    if (!isTRUE(all.equal(sum(x$probs), 1))) 
      warning("'space' does not have probability 1.")
  }
  A <- x[r, ]
  if (missing(given)) {
    p <- sum(A$probs)
  }
  else {
    f <- substitute(given)
    g <- eval(f, x, enclos = parent.frame())
    if (!is.logical(g)) {
      B <- given
    }
    else {
      g <- g & !is.na(g)
      B <- x[g, ]
    }
    p <- sum(intersect(A, B)$probs)/sum(B$probs)
  }
  return(p)
}

condproball <- function(dagdata){
  #only for discrete data, values need to be 0 and 1
  
  cndprbs <- list()
  cndprbs <- list(
    condprob(dagdata, X1==1),
    condprob(dagdata, X1==1, (Y==0)),
    condprob(dagdata, X1==1, (Y==1)),
    condprob(dagdata, X1==1, (X2==0)),
    condprob(dagdata, X1==1, (X2==1)),
    condprob(dagdata, X1==1, (Y==0 & X2==0)),
    condprob(dagdata, X1==1, (Y==1 & X2==0)),
    condprob(dagdata, X1==1, (Y==0 & X2==1)),
    condprob(dagdata, X1==1, (Y==1 & X2==1)),
    condprob(dagdata, Y==1),
    condprob(dagdata, Y==1, (X1==0)),
    condprob(dagdata, Y==1, (X1==1)),
    condprob(dagdata, Y==1, (X2==0)),
    condprob(dagdata, Y==1, (X2==1)),
    condprob(dagdata, Y==1, (X1==0 & X2==0)),
    condprob(dagdata, Y==1, (X1==1 & X2==0)),
    condprob(dagdata, Y==1, (X1==0 & X2==1)),
    condprob(dagdata, Y==1, (X1==1 & X2==1)),
    condprob(dagdata, X2==1),
    condprob(dagdata, X2==1, (Y==0)),
    condprob(dagdata, X2==1, (Y==1)),
    condprob(dagdata, X2==1, (X1==0)),
    condprob(dagdata, X2==1, (X1==1)),
    condprob(dagdata, X2==1, (Y==0 & X1==0)),
    condprob(dagdata, X2==1, (Y==1 & X1==0)),
    condprob(dagdata, X2==1, (Y==0 & X1==1)),
    condprob(dagdata, X2==1, (Y==1 & X1==1))
  )
  
  
  names(cndprbs) <- c(
    'X1',
    'X1|Y==0',
    'X1|Y==1',
    'X1|X2==0',
    'X1|X2==1', 
    'X1|Y==0 & X2==0',
    'X1|Y==1 & X2==0',
    'X1|Y==0 & X2==1',
    'X1|Y==1 & X2==1',
    'Y',
    'Y|X1==0',
    'Y|X1==1',
    'Y|X2==0',
    'Y|X2==1', 
    'Y|X1==0 & X2==0',
    'Y|X1==1 & X2==0',
    'Y|X1==0 & X2==1',
    'Y|X1==1 & X2==1',
    'X2',
    'X2|Y==0',
    'X2|Y==1',
    'X2|X1==0',
    'X2|X1==1', 
    'X2|Y==0 & X1==0',
    'X2|Y==1 & X1==0',
    'X2|Y==0 & X1==1',
    'X2|Y==1 & X1==1'
  )
  return(cndprbs)
}


condprobMS <- function(res){ 
  # Function to do conditional or marginal prob query on samples from runchainsMS
  # res = output runchainsMS function
  chainprobs <- list()
  for (i in 1:res$nchains){
    chainprobs[[i]] <- condproball(res$varjoint[[i]])
  }
  return(chainprobs)
}

guessMS <- function(chainprobs){
  # function to change NaNs to .5 in the prob queries, according to MS model
  # input should be output of condprobMS function.
  x <- chainprobs
  nchains <- length(x)
  for (i in 1:nchains){ #loop through chains
    for (ii in 1:27){   #loop through each prob query
      if (is.nan(x[[i]][[ii]])){
        x[[i]][ii] <- .5
      }
    }
  }
  return(x)
}

#function to get DF with all inferences from each chain based on relative frequency
preddistr <- function(res){
  # argument res is output from runchains
  chains <- res
  preddistr <- data.frame(matrix(ncol = 27, nrow = chains$nchains))
  colnames(preddistr) <- paste0("infnr", as.character(seq(1:27)))
  for (i in 1:chains$nchains){
    preddistr[i,1] <- chains$chainMSprobs[[i]]$`X1|X2==0` #infnr 1
    preddistr[i,2] <- chains$chainMSprobs[[i]]$`X1|X2==1` #infnr 2
    preddistr[i,3] <- chains$chainMSprobs[[i]]$`X1|Y==0` #infnr 3
    preddistr[i,4] <- chains$chainMSprobs[[i]]$`X1|Y==0 & X2==0` #infnr 4
    preddistr[i,5] <- chains$chainMSprobs[[i]]$`X1|Y==0 & X2==1` #infnr 5
    preddistr[i,6] <- chains$chainMSprobs[[i]]$`X1|Y==1` #infnr 6
    preddistr[i,7] <- chains$chainMSprobs[[i]]$`X1|Y==1 & X2==0` #infnr 7
    preddistr[i,8] <- chains$chainMSprobs[[i]]$`X1|Y==1 & X2==1` #infnr 8
    preddistr[i,9] <- chains$chainMSprobs[[i]]$`Y|X2==0` #infnr 9
    preddistr[i,10] <- chains$chainMSprobs[[i]]$`Y|X2==1` #infnr 10
    preddistr[i,11] <- chains$chainMSprobs[[i]]$`Y|X1==0` #infnr 11
    preddistr[i,12] <- chains$chainMSprobs[[i]]$`Y|X1==0 & X2==0` #infnr 12
    preddistr[i,13] <- chains$chainMSprobs[[i]]$`Y|X1==0 & X2==1` #infnr 13
    preddistr[i,14] <- chains$chainMSprobs[[i]]$`Y|X1==1` #infnr 14
    preddistr[i,15] <- chains$chainMSprobs[[i]]$`Y|X1==1 & X2==0` #infnr 15
    preddistr[i,16] <- chains$chainMSprobs[[i]]$`Y|X1==1 & X2==1` #infnr 16
    preddistr[i,17] <- chains$chainMSprobs[[i]]$`X2|Y==0` #infnr 17
    preddistr[i,18] <- chains$chainMSprobs[[i]]$`X2|Y==1` #infnr 18
    preddistr[i,19] <- chains$chainMSprobs[[i]]$`X2|X1==0` #infnr 19
    preddistr[i,20] <- chains$chainMSprobs[[i]]$`X2|Y==0 & X1==0` #infnr 20
    preddistr[i,21] <- chains$chainMSprobs[[i]]$`X2|Y==1 & X1==0` #infnr 21
    preddistr[i,22] <- chains$chainMSprobs[[i]]$`X2|X1==0` #infnr 22
    preddistr[i,23] <- chains$chainMSprobs[[i]]$`X2|Y==0 & X1==1` #infnr 23
    preddistr[i,24] <- chains$chainMSprobs[[i]]$`X2|Y==1 & X1==1` #infnr 24
    preddistr[i,25] <- chains$chainMSprobs[[i]]$`X1` #infnr 25
    preddistr[i,26] <- chains$chainMSprobs[[i]]$`Y` #infnr 26
    preddistr[i,27] <- chains$chainMSprobs[[i]]$`X2` #infnr 27
  }
  return(preddistr)
}





#######################################################
# Calculate probabilities based on betavar prior combined with relative frequency.
#######################################################
condprobBay <- function (x, betavar, len, event = NULL, given = NULL) {
  # calculates conditional or marginal probability based on combination of prior and relative freq in samples, kinda following Bayesian sampler paper
  # this is different function than  in condprop script, this is based on prob:::Prob.default
  # X is dataframe with column names as variables X1, Y, X2, and probs
  # betavar refers to prior, prior is betavar(betavar,betavar)
  # len = amount of samples / chain length.
  # event and given need to evaluate to logical expreesions (e.g. X1==1 or (X1=x=1&X2==0))
  # returns NaN if event and conditioning state is never observed
  if (!is.numeric(betavar)||!is.numeric(len)) {
    stop("betavar and or len is missing")
  }
  if (missing(event)) {
    r <- TRUE
  }
  else {
    e <- substitute(event)
    r <- eval(e, x, parent.frame())
    r <- r & !is.na(r)
    if (!isTRUE(all.equal(sum(x$probs), 1))) 
      warning("'space' does not have probability 1.")
  }
  A <- x[r, ] #part of x where event holds
  if (missing(given)) {
    p <- sum(A$probs)
  }
  else {
    f <- substitute(given)
    g <- eval(f, x, enclos = parent.frame())
    if (!is.logical(g)) {
      B <- given
    }
    else {
      g <- g & !is.na(g)
      B <- x[g, ] #part of x where given holds
    }
    p <- ((sum(intersect(A, B)$probs)*len)+betavar)/(sum((B$probs)*len) + 2*betavar)
  }
  return(p)
}

condproballBay <- function(dagdata, betavar, len){
  #only for discrete data, values need to be 0 and 1
  
  cndprbs <- list()
  cndprbs <- list(
    condprobBay(dagdata, betavar, len, X1==1),
    condprobBay(dagdata, betavar, len, X1==1, (Y==0)),
    condprobBay(dagdata, betavar, len, X1==1, (Y==1)),
    condprobBay(dagdata, betavar, len, X1==1, (X2==0)),
    condprobBay(dagdata, betavar, len, X1==1, (X2==1)),
    condprobBay(dagdata, betavar, len, X1==1, (Y==0 & X2==0)),
    condprobBay(dagdata, betavar, len, X1==1, (Y==1 & X2==0)),
    condprobBay(dagdata, betavar, len, X1==1, (Y==0 & X2==1)),
    condprobBay(dagdata, betavar, len, X1==1, (Y==1 & X2==1)),
    condprobBay(dagdata, betavar, len, Y==1),
    condprobBay(dagdata, betavar, len, Y==1, (X1==0)),
    condprobBay(dagdata, betavar, len, Y==1, (X1==1)),
    condprobBay(dagdata, betavar, len, Y==1, (X2==0)),
    condprobBay(dagdata, betavar, len, Y==1, (X2==1)),
    condprobBay(dagdata, betavar, len, Y==1, (X1==0 & X2==0)),
    condprobBay(dagdata, betavar, len, Y==1, (X1==1 & X2==0)),
    condprobBay(dagdata, betavar, len, Y==1, (X1==0 & X2==1)),
    condprobBay(dagdata, betavar, len, Y==1, (X1==1 & X2==1)),
    condprobBay(dagdata, betavar, len, X2==1),
    condprobBay(dagdata, betavar, len, X2==1, (Y==0)),
    condprobBay(dagdata, betavar, len, X2==1, (Y==1)),
    condprobBay(dagdata, betavar, len, X2==1, (X1==0)),
    condprobBay(dagdata, betavar, len, X2==1, (X1==1)),
    condprobBay(dagdata, betavar, len, X2==1, (Y==0 & X1==0)),
    condprobBay(dagdata, betavar, len, X2==1, (Y==1 & X1==0)),
    condprobBay(dagdata, betavar, len, X2==1, (Y==0 & X1==1)),
    condprobBay(dagdata, betavar, len, X2==1, (Y==1 & X1==1))
  )
  
  
  names(cndprbs) <- c(
    'X1',
    'X1|Y==0',
    'X1|Y==1',
    'X1|X2==0',
    'X1|X2==1', 
    'X1|Y==0 & X2==0',
    'X1|Y==1 & X2==0',
    'X1|Y==0 & X2==1',
    'X1|Y==1 & X2==1',
    'Y',
    'Y|X1==0',
    'Y|X1==1',
    'Y|X2==0',
    'Y|X2==1', 
    'Y|X1==0 & X2==0',
    'Y|X1==1 & X2==0',
    'Y|X1==0 & X2==1',
    'Y|X1==1 & X2==1',
    'X2',
    'X2|Y==0',
    'X2|Y==1',
    'X2|X1==0',
    'X2|X1==1', 
    'X2|Y==0 & X1==0',
    'X2|Y==1 & X1==0',
    'X2|Y==0 & X1==1',
    'X2|Y==1 & X1==1'
  )
  return(cndprbs)
}


condprobMSBay <- function(res){ 
  # Function to do conditional or marginal prob query on samples from runchainsMS
  # res = output runchainsMS function
  betavar <- res$betavar
  chainprobs <- list()
  for (i in 1:res$nchains){ # loop through chain
    len <- nrow(res$varsamples[[i]])
    chainprobs[[i]] <- condproballBay(res$varjoint[[i]], betavar, len)
  }
  return(chainprobs)
}


#function to get DF with all inferences from each chain based on relative frequency
preddistrBay <- function(res){
  # argument res is output from runchains
  chains <- res
  preddistr <- data.frame(matrix(ncol = 27, nrow = chains$nchains))
  colnames(preddistr) <- paste0("infnr", as.character(seq(1:27)))
  for (i in 1:chains$nchains){
    preddistr[i,1] <- chains$chainMSBayprobs[[i]]$`X1|X2==0` #infnr 1
    preddistr[i,2] <- chains$chainMSBayprobs[[i]]$`X1|X2==1` #infnr 2
    preddistr[i,3] <- chains$chainMSBayprobs[[i]]$`X1|Y==0` #infnr 3
    preddistr[i,4] <- chains$chainMSBayprobs[[i]]$`X1|Y==0 & X2==0` #infnr 4
    preddistr[i,5] <- chains$chainMSBayprobs[[i]]$`X1|Y==0 & X2==1` #infnr 5
    preddistr[i,6] <- chains$chainMSBayprobs[[i]]$`X1|Y==1` #infnr 6
    preddistr[i,7] <- chains$chainMSBayprobs[[i]]$`X1|Y==1 & X2==0` #infnr 7
    preddistr[i,8] <- chains$chainMSBayprobs[[i]]$`X1|Y==1 & X2==1` #infnr 8
    preddistr[i,9] <- chains$chainMSBayprobs[[i]]$`Y|X2==0` #infnr 9
    preddistr[i,10] <- chains$chainMSBayprobs[[i]]$`Y|X2==1` #infnr 10
    preddistr[i,11] <- chains$chainMSBayprobs[[i]]$`Y|X1==0` #infnr 11
    preddistr[i,12] <- chains$chainMSBayprobs[[i]]$`Y|X1==0 & X2==0` #infnr 12
    preddistr[i,13] <- chains$chainMSBayprobs[[i]]$`Y|X1==0 & X2==1` #infnr 13
    preddistr[i,14] <- chains$chainMSBayprobs[[i]]$`Y|X1==1` #infnr 14
    preddistr[i,15] <- chains$chainMSBayprobs[[i]]$`Y|X1==1 & X2==0` #infnr 15
    preddistr[i,16] <- chains$chainMSBayprobs[[i]]$`Y|X1==1 & X2==1` #infnr 16
    preddistr[i,17] <- chains$chainMSBayprobs[[i]]$`X2|Y==0` #infnr 17
    preddistr[i,18] <- chains$chainMSBayprobs[[i]]$`X2|Y==1` #infnr 18
    preddistr[i,19] <- chains$chainMSBayprobs[[i]]$`X2|X1==0` #infnr 19
    preddistr[i,20] <- chains$chainMSBayprobs[[i]]$`X2|Y==0 & X1==0` #infnr 20
    preddistr[i,21] <- chains$chainMSBayprobs[[i]]$`X2|Y==1 & X1==0` #infnr 21
    preddistr[i,22] <- chains$chainMSBayprobs[[i]]$`X2|X1==0` #infnr 22
    preddistr[i,23] <- chains$chainMSBayprobs[[i]]$`X2|Y==0 & X1==1` #infnr 23
    preddistr[i,24] <- chains$chainMSBayprobs[[i]]$`X2|Y==1 & X1==1` #infnr 24
    preddistr[i,25] <- chains$chainMSBayprobs[[i]]$`X1` #infnr 25
    preddistr[i,26] <- chains$chainMSBayprobs[[i]]$`Y` #infnr 26
    preddistr[i,27] <- chains$chainMSBayprobs[[i]]$`X2` #infnr 27
  }
  return(preddistr)
}


#######################################################
# Run the sampler
#######################################################

#see for updated setup mutationsampler plots script

len <- 5 # length of chain / amount of states sampled
meanlen <- 5
nchains <- 30 # number of chains
bias <- .5 #bias in starting point, now .5 (= prob state 1), meaning equal prob each prototype state
dag <- dagf1 #dag parametrization/frequency of states in normative model
res <- runchainsMSpoislen(meanlen,nchains,bias,dag) #create chains of samples

res$chainprobs[[2]]$`X1|Y==0 & X2==0`
res$chainMSprobs[[2]]$`X1|X2==0`
res$chainMSprobs[[2]][1]





